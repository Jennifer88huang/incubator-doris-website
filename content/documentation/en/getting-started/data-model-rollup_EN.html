

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Data Model, ROLLUP and Prefix Index &mdash; Doris Documentations 0.11.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Rollup and query" href="hit-the-rollup_EN.html" />
    <link rel="prev" title="Data Partition" href="data-partition_EN.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Doris Documentations
          

          
          </a>

          
            
            
              <div class="version">
                0.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cn/index.html">中文</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">English</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../downloads/index.html">Downloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installing/index.html">Compilation and Deployment</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Getting Started</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="basic-usage_EN.html">Guidelines for Basic Use</a></li>
<li class="toctree-l3"><a class="reference internal" href="advance-usage_EN.html">Advanced Use Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="best-practice_EN.html">Best Practices</a></li>
<li class="toctree-l3"><a class="reference internal" href="data-partition_EN.html">Data Partition</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Data Model, ROLLUP and Prefix Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-concepts">Basic concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregate-model">Aggregate Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uniq-model">Uniq Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#duplicate-model">Duplicate Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rollup">ROLLUP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#limitations-of-aggregation-model">Limitations of aggregation model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#suggestions-for-choosing-data-model">Suggestions for Choosing Data Model</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="hit-the-rollup_EN.html">Rollup and query</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../administrator-guide/index.html">Administrator Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../extending-doris/index.html">Extending Ability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/index.html">Design Documents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sql-reference/index.html">SQL Manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../developer-guide/index.html">Developer Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../community/index.html">Apache Commnity</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Doris Documentations</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">English</a> &raquo;</li>
        
          <li><a href="index.html">Getting Started</a> &raquo;</li>
        
      <li>Data Model, ROLLUP and Prefix Index</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/apache/incubator-doris/blob/master/docs/documentation/en/getting-started/data-model-rollup_EN.md" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- 
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
--><div class="section" id="data-model-rollup-and-prefix-index">
<h1>Data Model, ROLLUP and Prefix Index<a class="headerlink" href="#data-model-rollup-and-prefix-index" title="Permalink to this headline">¶</a></h1>
<p>This document describes Doris’s data model, ROLLUP and prefix index concepts at the logical level to help users better use Doris to cope with different business scenarios.</p>
<div class="section" id="basic-concepts">
<h2>Basic concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h2>
<p>In Doris, data is logically described in the form of tables.
A table consists of rows and columns. Row is a row of user data. Column is used to describe different fields in a row of data.</p>
<p>Columns can be divided into two categories: Key and Value. From a business perspective, Key and Value can correspond to dimension columns and indicator columns, respectively.</p>
<p>Doris’s data model is divided into three main categories:</p>
<ul class="simple">
<li>Aggregate</li>
<li>Uniq</li>
<li>Duplicate</li>
</ul>
<p>Let’s introduce them separately.</p>
</div>
<div class="section" id="aggregate-model">
<h2>Aggregate Model<a class="headerlink" href="#aggregate-model" title="Permalink to this headline">¶</a></h2>
<p>We illustrate what aggregation model is and how to use it correctly with practical examples.</p>
<div class="section" id="example-1-importing-data-aggregation">
<h3>Example 1: Importing data aggregation<a class="headerlink" href="#example-1-importing-data-aggregation" title="Permalink to this headline">¶</a></h3>
<p>Assume that the business has the following data table schema:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>LARGEINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>date of data filling</td>
</tr>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td></td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>User age</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td></td>
<td>User gender</td>
</tr>
<tr>
<td>Last_visit_date</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>Last user access time</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
<tr>
<td>max dwell time</td>
<td>INT</td>
<td>MAX</td>
<td>Maximum user residence time</td>
</tr>
<tr>
<td>min dwell time</td>
<td>INT</td>
<td>MIN</td>
<td>User minimum residence time</td>
</tr>
</tbody>
</table><p>If converted into a table-building statement, the following is done (omitting the Partition and Distribution information in the table-building statement)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CREATE TABLE IF NOT EXISTS example_db.expamle_tbl
(
    `user_id` LARGEINT NOT NULL COMMENT &quot;user id&quot;,
    `date` DATE NOT NULL COMMENT &quot;data import time&quot;,
    `city` VARCHAR(20) COMMENT &quot;city&quot;,
    `age` SMALLINT COMMENT &quot;age&quot;,
    `sex` TINYINT COMMENT &quot;gender&quot;,
    `last_visit_date` DATETIME REPLACE DEFAULT &quot;1970-01-01 00:00:00&quot; COMMENT &quot;last visit date time&quot;,
    `cost` BIGINT SUM DEFAULT &quot;0&quot; COMMENT &quot;user total cost&quot;,
    `max_dwell_time` INT MAX DEFAULT &quot;0&quot; COMMENT &quot;user max dwell time&quot;,
    `min_dwell_time` INT MIN DEFAULT &quot;99999&quot; COMMENT &quot;user min dwell time&quot;,
)
AGGREGATE KEY(`user_id`, `date`, `timestamp`, `city`, `age`, `sex`)
... /* ignore Partition and Distribution */
;
</pre></div>
</div>
<p>As you can see, this is a typical fact table of user information and access behavior.
In general star model, user information and access behavior are stored in dimension table and fact table respectively. Here, in order to explain Doris’s data model more conveniently, we store the two parts of information in a single table.</p>
<p>The columns in the table are divided into Key (dimension column) and Value (indicator column) according to whether <code class="docutils literal notranslate"><span class="pre">AggregationType</span></code>is set or not. No <code class="docutils literal notranslate"><span class="pre">AggregationType</span></code>, such as <code class="docutils literal notranslate"><span class="pre">user_id</span></code>, <code class="docutils literal notranslate"><span class="pre">date</span></code>, <code class="docutils literal notranslate"><span class="pre">age</span></code>, etc., is set as <strong>Key</strong>, while AggregationType’is set as <strong>Value</strong>.</p>
<p>When we import data, the same rows and aggregates into one row for the Key column, while the Value column aggregates according to the set <code class="docutils literal notranslate"><span class="pre">AggregationType</span></code>. <code class="docutils literal notranslate"><span class="pre">AggregationType</span></code>currently has the following four ways of aggregation:</p>
<ol class="simple">
<li>SUM: Sum, multi-line Value accumulation.</li>
<li>REPLACE: Instead, Values in the next batch of data will replace Values in rows previously imported.</li>
<li>MAX: Keep the maximum.</li>
<li>MIN: Keep the minimum.</li>
</ol>
<p>Suppose we have the following imported data (raw data):</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>Let’s assume that this is a table that records the user’s behavior in accessing a commodity page. Let’s take the first row of data as an example and explain it as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Data</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>User id, each user uniquely identifies id</td>
</tr>
<tr>
<td>2017-10-01</td>
<td>Data storage time, accurate to date</td>
</tr>
<tr>
<td>Beijing</td>
<td>User City</td>
</tr>
<tr>
<td>20</td>
<td>User Age</td>
</tr>
<tr>
<td>0</td>
<td>Gender male (1 for female)</td>
</tr>
<tr>
<td>2017-10-01 06:00</td>
<td>User's time to visit this page, accurate to seconds</td>
</tr>
<tr>
<td>20</td>
<td>Consumption generated by the user's current visit</td>
</tr>
<tr>
<td>10</td>
<td>User's visit, time to stay on the page</td>
</tr>
<tr>
<td>10</td>
<td>User's current visit, time spent on the page (redundancy)</td>
</tr>
</tbody>
</table><p>Then when this batch of data is imported into Doris correctly, the final storage in Doris is is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>35</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>As you can see, there is only one line of aggregated data left for 10,000 users. The data of other users are consistent with the original data. Here we first explain the aggregated data of user 10000:</p>
<p>The first five columns remain unchanged, starting with column 6 `last_visit_date’:</p>
<p>*<code class="docutils literal notranslate"><span class="pre">2017-10-01</span> <span class="pre">07:00</span></code>: Because the <code class="docutils literal notranslate"><span class="pre">last_visit_date</span></code>column is aggregated by REPLACE, the <code class="docutils literal notranslate"><span class="pre">2017-10-01</span> <span class="pre">07:00</span></code> column has been replaced by `2017-10-01 06:00’.</p>
<blockquote>
<div>Note: For data in the same import batch, the order of replacement is not guaranteed for the aggregation of REPLACE. For example, in this case, it may be `2017-10-01 06:00’. For data from different imported batches, it can be guaranteed that the data from the latter batch will replace the former batch.</div></blockquote>
<p>*<code class="docutils literal notranslate"><span class="pre">35</span></code>: Because the aggregation type of the <code class="docutils literal notranslate"><span class="pre">cost'column</span> <span class="pre">is</span> <span class="pre">SUM,</span> <span class="pre">35</span> <span class="pre">is</span> <span class="pre">accumulated</span> <span class="pre">from</span> <span class="pre">20</span> <span class="pre">+</span> <span class="pre">15.</span> <span class="pre">*</span></code>10<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">Because</span> <span class="pre">the</span> <span class="pre">aggregation</span> <span class="pre">type</span> <span class="pre">of</span> <span class="pre">the</span></code>max_dwell_time’column is MAX, 10 and 2 take the maximum and get 10.
*<code class="docutils literal notranslate"><span class="pre">2</span></code>: Because the aggregation type of `min_dwell_time’column is MIN, 10 and 2 take the minimum value and get 2.</p>
<p>After aggregation, Doris ultimately only stores aggregated data. In other words, detailed data will be lost and users can no longer query the detailed data before aggregation.</p>
</div>
<div class="section" id="example-2-keep-detailed-data">
<h3>Example 2: Keep detailed data<a class="headerlink" href="#example-2-keep-detailed-data" title="Permalink to this headline">¶</a></h3>
<p>Following example 1, we modify the table structure as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>LARGEINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>date of data filling</td>
</tr>
<tr>
<td>Time stamp</td>
<td>DATETIME</td>
<td></td>
<td>Data filling time, accurate to seconds</td>
</tr>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td></td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>User age</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td></td>
<td>User gender</td>
</tr>
<tr>
<td>Last visit date</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>Last user access time</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
<tr>
<td>max dwell time</td>
<td>INT</td>
<td>MAX</td>
<td>Maximum user residence time</td>
</tr>
<tr>
<td>min dwell time</td>
<td>INT</td>
<td>MIN</td>
<td>User minimum residence time</td>
</tr>
</tbody>
</table><p>That is to say, a column of `timestamp’has been added to record the data filling time accurate to seconds.</p>
<p>The imported data are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>timestamp</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 08:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 09:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>2017-10-01 18:12:10</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>2017-10-02 13:10:00</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>2017-10-02 13:15:00</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>2017-10-01 12:12:48</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>2017-10-03 12:38:20</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>Then when this batch of data is imported into Doris correctly, the final storage in Doris is is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>timestamp</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 08:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 09:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>2017-10-01 18:12:10</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>2017-10-02 13:10:00</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>2017-10-02 13:15:00</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>2017-10-01 12:12:48</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>2017-10-03 12:38:20</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>We can see that the stored data, just like the imported data, does not aggregate at all. This is because, in this batch of data, because the `timestamp’column is added, the Keys of all rows are <strong>not exactly the same</strong>. That is, as long as the keys of each row are not identical in the imported data, Doris can save the complete detailed data even in the aggregation model.</p>
</div>
<div class="section" id="example-3-importing-data-and-aggregating-existing-data">
<h3>Example 3: Importing data and aggregating existing data<a class="headerlink" href="#example-3-importing-data-and-aggregating-existing-data" title="Permalink to this headline">¶</a></h3>
<p>Take Example 1. Suppose that the data in the table are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>35</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>We imported a new batch of data:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 11:22:00</td>
<td>44</td>
<td>19</td>
<td>19</td>
</tr>
<tr>
<td>10005</td>
<td>2017-10-03</td>
<td>Changsha</td>
<td>29</td>
<td>1</td>
<td>2017-10-03 18:11:02</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><p>Then when this batch of data is imported into Doris correctly, the final storage in Doris is is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>35</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 11:22:00</td>
<td>55</td>
<td>19</td>
<td>6</td>
</tr>
<tr>
<td>10005</td>
<td>2017-10-03</td>
<td>Changsha</td>
<td>29</td>
<td>1</td>
<td>2017-10-03 18:11:02</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><p>As you can see, the existing data and the newly imported data of user 10004 have been aggregated. At the same time, 10005 new users’data were added.</p>
<p>Data aggregation occurs in Doris in the following three stages:</p>
<ol class="simple">
<li>The ETL stage of data import for each batch. This phase aggregates data within each batch of imported data.</li>
<li>The stage in which the underlying BE performs data Compaction. At this stage, BE aggregates data from different batches that have been imported.</li>
<li>Data query stage. In data query, the data involved in the query will be aggregated accordingly.</li>
</ol>
<p>Data may be aggregated to varying degrees at different times. For example, when a batch of data is just imported, it may not be aggregated with the existing data. But for users, user<strong>can only query aggregated data</strong>. That is, different degrees of aggregation are transparent to user queries. Users should always assume that data exists in terms of the degree of aggregation that <strong>ultimately completes</strong>, and <strong>should not assume that some aggregation has not yet occurred</strong>. (See the section <strong>Limitations of the aggregation model</strong> for more details.)</p>
</div>
</div>
<div class="section" id="uniq-model">
<h2>Uniq Model<a class="headerlink" href="#uniq-model" title="Permalink to this headline">¶</a></h2>
<p>In some multi-dimensional analysis scenarios, users are more concerned with how to ensure the uniqueness of Key, that is, how to obtain the Primary Key uniqueness constraint. Therefore, we introduce Uniq’s data model. This model is essentially a special case of aggregation model and a simplified representation of table structure. Let’s give an example.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>IsKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td>Yes</td>
<td>user id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR (50)</td>
<td>Yes</td>
<td>User nickname</td>
</tr>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td>No</td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>No</td>
<td>User Age</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>No</td>
<td>User Gender</td>
</tr>
<tr>
<td>Phone</td>
<td>LARGEINT</td>
<td>No</td>
<td>User Phone</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR (500)</td>
<td>No</td>
<td>User Address</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>No</td>
<td>user registration time</td>
</tr>
</tbody>
</table><p>This is a typical user base information table. There is no aggregation requirement for this type of data, just the uniqueness of the primary key is guaranteed. (The primary key here is user_id + username). Then our statement is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CREATE TABLE IF NOT EXISTS example_db.expamle_tbl
(
`user_id` LARGEINT NOT NULL COMMENT &quot;用户id&quot;,
&quot;username&quot; VARCHAR (50) NOT NULL COMMENT &quot;25143;&quot; 261651;&quot;
` City `VARCHAR (20) COMMENT `User City&#39;,
&quot;Age&quot; SMALLINT COMMENT &quot;29992;&quot; 25143;&quot;24180;&quot; 40836 &quot;,
`sex` TINYINT COMMENT &quot;用户性别&quot;,
`phone` LARGEINT COMMENT &quot;用户电话&quot;,
&#39;address ` VARCHAR (500) COMMENT&#39;25143;&#39;,
&#39;register &#39;or&#39;time&#39; DATETIME COMMENT &quot;29992;&quot; 25143;&quot;27880;&quot; 20876;&quot;26102;&quot; 38388;&quot;
)
Unique Key (&quot;User&quot;, &quot;User&quot;, &quot;Name&quot;)
... /* 省略 Partition 和 Distribution 信息 */
;
</pre></div>
</div>
<p>This table structure is exactly the same as the following table structure described by the aggregation model:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR (50)</td>
<td></td>
<td>User nickname</td>
</tr>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td>REPLACE</td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>REPLACE</td>
<td>User Age</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>REPLACE</td>
<td>User Gender</td>
</tr>
<tr>
<td>Phone</td>
<td>LARGEINT</td>
<td>REPLACE</td>
<td>User Phone</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR (500)</td>
<td>REPLACE</td>
<td>User Address</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>User registration time</td>
</tr>
</tbody>
</table><p>And table-building statements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CREATE TABLE IF NOT EXISTS example_db.expamle_tbl
(
`user_id` LARGEINT NOT NULL COMMENT &quot;用户id&quot;,
&quot;username&quot; VARCHAR (50) NOT NULL COMMENT &quot;25143;&quot; 261651;&quot;
` City `VARCHAR (20) REPLACE COMMENT `User City&#39;,
What do you say when you are young?
`sex` TINYINT REPLACE COMMENT &quot;用户性别&quot;,
&quot;phone&quot; LARGEINT REPLACE COMMENT &quot;25143;&quot;
`address` VARCHAR(500) REPLACE COMMENT &quot;用户地址&quot;,
&#39;register &#39;or&#39;time&#39; DATETIME REPLACE COMMENT &quot;29992;&quot; 25143;&quot;27880;&quot; 20876;&quot;26102;&quot;
)
AGGREGATE KEY(`user_id`, `user_name`)
... /* 省略 Partition 和 Distribution 信息 */
;
</pre></div>
</div>
<p>That is to say, Uniq model can be completely replaced by REPLACE in aggregation model. Its internal implementation and data storage are exactly the same. No further examples will be given here.</p>
</div>
<div class="section" id="duplicate-model">
<h2>Duplicate Model<a class="headerlink" href="#duplicate-model" title="Permalink to this headline">¶</a></h2>
<p>In some multidimensional analysis scenarios, data has neither primary keys nor aggregation requirements. Therefore, we introduce Duplicate data model to meet this kind of demand. Examples are given.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>SortKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Timstamp</td>
<td>DATETIME</td>
<td>Yes</td>
<td>Logging Time</td>
</tr>
<tr>
<td>Type</td>
<td>INT</td>
<td>Yes</td>
<td>Log Type</td>
</tr>
<tr>
<td>error_code</td>
<td>INT</td>
<td>Yes</td>
<td>error code</td>
</tr>
<tr>
<td>Error_msg</td>
<td>VARCHAR (1024)</td>
<td>No</td>
<td>Error Details</td>
</tr>
<tr>
<td>op_id</td>
<td>BIGINT</td>
<td>No</td>
<td>operator id</td>
</tr>
<tr>
<td>op_time</td>
<td>DATETIME</td>
<td>No</td>
<td>operation time</td>
</tr>
</tbody>
</table><p>The TABLE statement is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CREATE TABLE IF NOT EXISTS example_db.expamle_tbl
(
`timestamp` DATETIME NOT NULL COMMENT &quot;日志时间&quot;,
`type` INT NOT NULL COMMENT &quot;日志类型&quot;,
&quot;Error&quot;\\\\\\\\\\\\\
`error_msg` VARCHAR(1024) COMMENT &quot;错误详细信息&quot;,
`op_id` BIGINT COMMENT &quot;负责人id&quot;,
OP `op `time ` DATETIME COMMENT &quot;22788;&quot; 29702;&quot;26102;&quot; 388;&quot;
)
DUPLICATE KEY(`timestamp`, `type`)
... /* 省略 Partition 和 Distribution 信息 */
;
</pre></div>
</div>
<p>This data model is different from Aggregate and Uniq models. Data is stored entirely in accordance with the data in the imported file, without any aggregation. Even if the two rows of data are identical, they will be retained.
The DUPLICATE KEY specified in the table building statement is only used to specify which columns the underlying data is sorted according to. (The more appropriate name should be “Sorted Column”, where the name “DUPLICATE KEY” is used to specify the data model used. For more explanations of “Sorted Column”, see the section ** Prefix Index **. On the choice of DUPLICATE KEY, we recommend that the first 2-4 columns be selected appropriately.</p>
<p>This data model is suitable for storing raw data without aggregation requirements and primary key uniqueness constraints. For more usage scenarios, see the ** Limitations of the Aggregation Model ** section.</p>
</div>
<div class="section" id="rollup">
<h2>ROLLUP<a class="headerlink" href="#rollup" title="Permalink to this headline">¶</a></h2>
<p>ROLLUP in multidimensional analysis means “scroll up”, which means that data is aggregated further at a specified granularity.</p>
<div class="section" id="id1">
<h3>Basic concepts<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In Doris, we make the table created by the user through the table building statement a Base table. Base table holds the basic data stored in the way specified by the user’s table-building statement.</p>
<p>On top of the Base table, we can create any number of ROLLUP tables. These ROLLUP data are generated based on the Base table and physically <strong>stored independently</strong>.</p>
<p>The basic function of ROLLUP tables is to obtain coarser aggregated data on the basis of Base tables.</p>
<p>Let’s illustrate the ROLLUP tables and their roles in different data models with examples.</p>
<div class="section" id="rollup-in-aggregate-model-and-uniq-model">
<h4>ROLLUP in Aggregate Model and Uniq Model<a class="headerlink" href="#rollup-in-aggregate-model-and-uniq-model" title="Permalink to this headline">¶</a></h4>
<p>Because Uniq is only a special case of the Aggregate model, we do not distinguish it here.</p>
<p>Example 1: Get the total consumption per user</p>
<p>Following <strong>Example 2</strong> in the <strong>Aggregate Model</strong> section, the Base table structure is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>LARGEINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>date of data filling</td>
</tr>
<tr>
<td>Time stamp</td>
<td>DATETIME</td>
<td></td>
<td>Data filling time, accurate to seconds</td>
</tr>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td></td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>User age</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td></td>
<td>User gender</td>
</tr>
<tr>
<td>Last_visit_date</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>Last user access time</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
<tr>
<td>max dwell time</td>
<td>INT</td>
<td>MAX</td>
<td>Maximum user residence time</td>
</tr>
<tr>
<td>min dwell time</td>
<td>INT</td>
<td>MIN</td>
<td>User minimum residence time</td>
</tr>
</tbody>
</table><p>The data stored are as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>timestamp</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 08:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>2017-10-01 09:00:05</td>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>2017-10-01 18:12:10</td>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>2017-10-02 13:10:00</td>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>2017-10-02 13:15:00</td>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>2017-10-01 12:12:48</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>2017-10-03 12:38:20</td>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table><p>On this basis, we create a ROLLUP:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
</tr>
<tr>
<td>cost</td>
</tr>
</tbody>
</table><p>The ROLLUP contains only two columns: user_id and cost. After the creation, the data stored in the ROLLUP is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>35</td>
</tr>
<tr>
<td>10001</td>
<td>2</td>
</tr>
<tr>
<td>10002</td>
<td>200</td>
</tr>
<tr>
<td>10003</td>
<td>30</td>
</tr>
<tr>
<td>10004</td>
<td>111</td>
</tr>
</tbody>
</table><p>As you can see, ROLLUP retains only the results of SUM on the cost column for each user_id. So when we do the following query:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">user_id,</span> <span class="pre">sum(cost)</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">GROUP</span> <span class="pre">BY</span> <span class="pre">user_id;</span></code></p>
<p>Doris automatically hits the ROLLUP table, thus completing the aggregated query by scanning only a very small amount of data.</p>
<ol class="simple">
<li>Example 2: Get the total consumption, the longest and shortest page residence time of users of different ages in different cities</li>
</ol>
<p>Follow example 1. Based on the Base table, we create a ROLLUP:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>City</td>
<td>VARCHAR (20)</td>
<td></td>
<td>User City</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>User age</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
<tr>
<td>max dwell time</td>
<td>INT</td>
<td>MAX</td>
<td>Maximum user residence time</td>
</tr>
<tr>
<td>min dwell time</td>
<td>INT</td>
<td>MIN</td>
<td>User minimum residence time</td>
</tr>
</tbody>
</table><p>After the creation, the data stored in the ROLLUP is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>city</th>
<th>age</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beijing</td>
<td>20</td>
<td>0</td>
<td>30</td>
<td>10</td>
</tr>
<tr>
<td>Beijing</td>
<td>30</td>
<td>1</td>
<td>2</td>
<td>22</td>
</tr>
<tr>
<td>Shanghai</td>
<td>20</td>
<td>1</td>
<td>200</td>
<td>5</td>
</tr>
<tr>
<td>Guangzhou</td>
<td>32</td>
<td>0</td>
<td>30</td>
<td>11</td>
</tr>
<tr>
<td>Shenzhen</td>
<td>35</td>
<td>0</td>
<td>111</td>
<td>6</td>
</tr>
</tbody>
</table><p>When we do the following queries:</p>
<ul class="simple">
<li>Select City, Age, Sum (Cost), Max (Max dwell time), min (min dwell time) from table group by City, age;*</li>
<li><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">city,</span> <span class="pre">sum(cost),</span> <span class="pre">max(max_dwell_time),</span> <span class="pre">min(min_dwell_time)</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">GROUP</span> <span class="pre">BY</span> <span class="pre">city;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">city,</span> <span class="pre">age,</span> <span class="pre">sum(cost),</span> <span class="pre">min(min_dwell_time)</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">GROUP</span> <span class="pre">BY</span> <span class="pre">city,</span> <span class="pre">age;</span></code></li>
</ul>
<p>Doris automatically hits the ROLLUP table.</p>
</div>
<div class="section" id="ollup-in-duplicate-model">
<h4>OLLUP in Duplicate Model<a class="headerlink" href="#ollup-in-duplicate-model" title="Permalink to this headline">¶</a></h4>
<p>Because the Duplicate model has no aggregate semantics. So the ROLLLUP in this model has lost the meaning of “scroll up”. It’s just to adjust the column order to hit the prefix index. In the next section, we will introduce prefix index in detail, and how to use ROLLUP to change prefix index in order to achieve better query efficiency.</p>
</div>
</div>
<div class="section" id="prefix-index-and-rollup">
<h3>Prefix Index and ROLLUP<a class="headerlink" href="#prefix-index-and-rollup" title="Permalink to this headline">¶</a></h3>
<div class="section" id="prefix-index">
<h4>prefix index<a class="headerlink" href="#prefix-index" title="Permalink to this headline">¶</a></h4>
<p>Unlike traditional database design, Doris does not support indexing on any column. OLAP databases based on MPP architecture such as Doris usually handle large amounts of data by improving concurrency.
In essence, Doris’s data is stored in a data structure similar to SSTable (Sorted String Table). This structure is an ordered data structure, which can be sorted and stored according to the specified column. In this data structure, it is very efficient to search by sorting columns.</p>
<p>In Aggregate, Uniq and Duplicate three data models. The underlying data storage is sorted and stored according to the columns specified in AGGREGATE KEY, UNIQ KEY and DUPLICATE KEY in their respective table-building statements.</p>
<p>The prefix index, which is based on sorting, implements an index method to query data quickly according to a given prefix column.</p>
<p>We use the prefix index of ** 36 bytes ** of a row of data as the prefix index of this row of data. When a VARCHAR type is encountered, the prefix index is truncated directly. We give examples to illustrate:</p>
<ol class="simple">
<li>The prefix index of the following table structure is user_id (8Byte) + age (8Bytes) + message (prefix 20 Bytes).</li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
</tr>
<tr>
<td>age</td>
<td>INT</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>DATETIME</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>DATETIME</td>
</tr>
</tbody>
</table><ol class="simple">
<li>The prefix index of the following table structure is user_name (20 Bytes). Even if it does not reach 36 bytes, because it encounters VARCHAR, it truncates directly and no longer continues.</li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_name</td>
<td>VARCHAR(20)</td>
</tr>
<tr>
<td>age</td>
<td>INT</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>DATETIME</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>DATETIME</td>
</tr>
</tbody>
</table><p>When our query condition is the prefix of ** prefix index **, it can greatly speed up the query speed. For example, in the first example, we execute the following queries:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">WHERE</span> <span class="pre">user_id=1829239</span> <span class="pre">and</span> <span class="pre">age=20；</span></code></p>
<p>The efficiency of this query is much higher than that of ** the following queries:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">WHERE</span> <span class="pre">age=20；</span></code></p>
<p>Therefore, when constructing tables, ** correctly choosing column order can greatly improve query efficiency **.</p>
</div>
<div class="section" id="rollup-adjusts-prefix-index">
<h4>ROLLUP adjusts prefix index<a class="headerlink" href="#rollup-adjusts-prefix-index" title="Permalink to this headline">¶</a></h4>
<p>Because column order is specified when a table is built, there is only one prefix index for a table. This may be inefficient for queries that use other columns that cannot hit prefix indexes as conditions. Therefore, we can manually adjust the order of columns by creating ROLLUP. Examples are given.</p>
<p>The structure of the Base table is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
</tr>
<tr>
<td>age</td>
<td>INT</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>DATETIME</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>DATETIME</td>
</tr>
</tbody>
</table><p>On this basis, we can create a ROLLUP table:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>age</td>
<td>INT</td>
</tr>
<tr>
<td>user_id</td>
<td>BIGINT</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>DATETIME</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>DATETIME</td>
</tr>
</tbody>
</table><p>As you can see, the columns of ROLLUP and Base tables are exactly the same, just changing the order of user_id and age. So when we do the following query:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">where</span> <span class="pre">age=20</span> <span class="pre">and</span> <span class="pre">massage</span> <span class="pre">LIKE</span> <span class="pre">&quot;%error%&quot;;</span></code></p>
<p>The ROLLUP table is preferred because the prefix index of ROLLUP matches better.</p>
</div>
</div>
<div class="section" id="some-explanations-of-rollup">
<h3>Some Explanations of ROLLUP<a class="headerlink" href="#some-explanations-of-rollup" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>The fundamental role of ROLLUP is to improve the query efficiency of some queries (whether by aggregating to reduce the amount of data or by modifying column order to match prefix indexes). Therefore, the meaning of ROLLUP has gone beyond the scope of “roll-up”. That’s why we named it Materized Index in the source code.</li>
<li>ROLLUP is attached to the Base table and can be seen as an auxiliary data structure of the Base table. Users can create or delete ROLLUP based on the Base table, but cannot explicitly specify a query for a ROLLUP in the query. Whether ROLLUP is hit or not is entirely determined by the Doris system.</li>
<li>ROLLUP data is stored in separate physical storage. Therefore, the more OLLUP you create, the more disk space you occupy. It also has an impact on the speed of import (the ETL phase of import automatically generates all ROLLUP data), but it does not reduce query efficiency (only better).</li>
<li>Data updates for ROLLUP are fully synchronized with Base representations. Users need not care about this problem.</li>
<li>Columns in ROLLUP are aggregated in exactly the same way as Base tables. There is no need to specify or modify ROLLUP when creating it.</li>
<li>A necessary (inadequate) condition for a query to hit ROLLUP is that all columns ** (including the query condition columns in select list and where) involved in the query exist in the column of the ROLLUP. Otherwise, the query can only hit the Base table.</li>
<li>Certain types of queries (such as count (*)) cannot hit ROLLUP under any conditions. See the next section <strong>Limitations of the aggregation model</strong>.</li>
<li>The query execution plan can be obtained by <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span> <span class="pre">your_sql;</span></code> command, and in the execution plan, whether ROLLUP has been hit or not can be checked.</li>
<li>Base tables and all created ROLLUPs can be displayed by <code class="docutils literal notranslate"><span class="pre">DESC</span> <span class="pre">tbl_name</span> <span class="pre">ALL;</span></code> statement.</li>
</ul>
<p>In this document, you can see [Query how to hit Rollup] (hit-the-rollup)</p>
</div>
</div>
<div class="section" id="limitations-of-aggregation-model">
<h2>Limitations of aggregation model<a class="headerlink" href="#limitations-of-aggregation-model" title="Permalink to this headline">¶</a></h2>
<p>Here we introduce the limitations of Aggregate model (including Uniq model).</p>
<p>In the aggregation model, what the model presents is the aggregated data. That is to say, any data that has not yet been aggregated (for example, two different imported batches) must be presented in some way to ensure consistency. Let’s give an example.</p>
<p>The hypothesis table is structured as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>LARGEINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>date of data filling</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
</tbody>
</table><p>Assume that there are two batches of data that have been imported into the storage engine as follows:</p>
<p><strong>batch 1</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table><p><strong>batch 2</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table><p>As you can see, data belonging to user 10001 in two import batches has not yet been aggregated. However, in order to ensure that users can only query the aggregated data as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table><p>We add aggregation operator to query engine to ensure data consistency.</p>
<p>In addition, on the aggregate column (Value), when executing aggregate class queries that are inconsistent with aggregate types, attention should be paid to semantics. For example, in the example above, we execute the following queries:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">MIN(cost)</span> <span class="pre">FROM</span> <span class="pre">table;</span></code></p>
<p>The result is 5, not 1.</p>
<p>At the same time, this consistency guarantee will greatly reduce the query efficiency in some queries.</p>
<p>Let’s take the most basic count (*) query as an example:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">COUNT(*)</span> <span class="pre">FROM</span> <span class="pre">table;</span></code></p>
<p>In other databases, such queries return results quickly. Because in the implementation, we can get the query result by counting rows at the time of import and saving count statistics information, or by scanning only a column of data to get count value at the time of query, with very little overhead. But in Doris’s aggregation model, the overhead of this query ** is very large **.</p>
<p>Let’s take the data as an example.</p>
<p><strong>batch 1</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table><p><strong>batch 2</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table><p>Because the final aggregation result is:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table><p>So <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">count</span> <span class="pre">(*)</span> <span class="pre">from</span> <span class="pre">table;</span></code> The correct result should be <strong>4</strong>. But if we only scan the `user_id’column and add query aggregation, the final result is <strong>3</strong> (10001, 10002, 10003). If aggregated without queries, the result is <strong>5</strong> (a total of five rows in two batches). It can be seen that both results are wrong.</p>
<p>In order to get the correct result, we must read the data of <code class="docutils literal notranslate"><span class="pre">user_id</span></code> and <code class="docutils literal notranslate"><span class="pre">date</span></code>, and <strong>together with aggregate</strong> when querying, to return the correct result of <strong>4</strong>. That is to say, in the count (<em>) query, Doris must scan all AGGREGATE KEY columns (here are <code class="docutils literal notranslate"><span class="pre">user_id</span></code> and <code class="docutils literal notranslate"><span class="pre">date</span></code>) and aggregate them to get the semantically correct results. When aggregated columns are large, count (</em>) queries need to scan a large amount of data.</p>
<p>Therefore, when there are frequent count (<em>) queries in the business, we recommend that users simulate count (</em>) by adding a column with a value of 1 and aggregation type of SUM. As the table structure in the previous example, we modify it as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user ID</td>
<td>BIGINT</td>
<td></td>
<td>user id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>date of data filling</td>
</tr>
<tr>
<td>Cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>Total User Consumption</td>
</tr>
<tr>
<td>count</td>
<td>BIGINT</td>
<td>SUM</td>
<td>for counting</td>
</tr>
</tbody>
</table><p>Add a count column and import the data with the column value <strong>equal to 1</strong>. The result of <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">count</span> <span class="pre">(*)</span> <span class="pre">from</span> <span class="pre">table;</span></code>is equivalent to <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">sum</span> <span class="pre">(count)</span> <span class="pre">from</span> <span class="pre">table;</span></code> The query efficiency of the latter is much higher than that of the former. However, this method also has limitations, that is, users need to guarantee that they will not import rows with the same AGGREGATE KEY column repeatedly. Otherwise, <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">sum</span> <span class="pre">(count)</span> <span class="pre">from</span> <span class="pre">table;</span></code>can only express the number of rows originally imported, not the semantics of <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">count</span> <span class="pre">(*)</span> <span class="pre">from</span> <span class="pre">table;</span></code></p>
<p>Another way is to <strong>change the aggregation type of the count’column above to REPLACE, and still weigh 1</strong>. Then<code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">sum</span> <span class="pre">(count)</span> <span class="pre">from</span> <span class="pre">table;</span></code> and <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">count</span> <span class="pre">(*)</span> <span class="pre">from</span> <span class="pre">table;</span></code> the results will be consistent. And in this way, there is no restriction on importing duplicate rows.</p>
<div class="section" id="id2">
<h3>Duplicate Model<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Duplicate model has no limitation of aggregation model. Because the model does not involve aggregate semantics, when doing count (*) query, we can get the correct semantics by choosing a column of queries arbitrarily.</p>
</div>
</div>
<div class="section" id="suggestions-for-choosing-data-model">
<h2>Suggestions for Choosing Data Model<a class="headerlink" href="#suggestions-for-choosing-data-model" title="Permalink to this headline">¶</a></h2>
<p>Because the data model was established when the table was built, and **could not be modified <strong>. Therefore, it is very important to select an appropriate data model</strong>.</p>
<ol class="simple">
<li>Aggregate model can greatly reduce the amount of data scanned and the amount of query computation by pre-aggregation. It is very suitable for report query scenarios with fixed patterns. But this model is not very friendly for count (*) queries. At the same time, because the aggregation method on the Value column is fixed, semantic correctness should be considered in other types of aggregation queries.</li>
<li>Uniq model guarantees the uniqueness of primary key for scenarios requiring unique primary key constraints. However, the query advantage brought by pre-aggregation such as ROLLUP can not be exploited (because the essence is REPLACE, there is no such aggregation as SUM).</li>
<li>Duplicate is suitable for ad-hoc queries of any dimension. Although it is also impossible to take advantage of the pre-aggregation feature, it is not constrained by the aggregation model and can take advantage of the queue-store model (only reading related columns, but not all Key columns).</li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hit-the-rollup_EN.html" class="btn btn-neutral float-right" title="Rollup and query" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="data-partition_EN.html" class="btn btn-neutral float-left" title="Data Partition" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Apache Doris(Incubating)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
<div role="contentinfo">
    <p></p>
    <p>

        Apache Doris(incubating) is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.

    </p>
</div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>