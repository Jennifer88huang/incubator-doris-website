

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>调试工具 &mdash; Doris Documentations 0.11.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Apache 社区" href="../community/index.html" />
    <link rel="prev" title="开发者手册" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Doris Documentations
          

          
          </a>

          
            
            
              <div class="version">
                0.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">中文</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../installing/index.html">编译与部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/index.html">开始使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../administrator-guide/index.html">操作手册</a></li>
<li class="toctree-l2"><a class="reference internal" href="../extending-doris/index.html">扩展功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../internal/index.html">设计文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sql-reference/index.html">SQL 手册</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">开发者手册</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">调试工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">环境准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu">CPU</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../community/index.html">Apache 社区</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../en/index.html">English</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Doris Documentations</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">中文</a> &raquo;</li>
        
          <li><a href="index.html">开发者手册</a> &raquo;</li>
        
      <li>调试工具</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/apache/incubator-doris/blob/master/docs/documentation/cn/developer-guide/debug-tool.md" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- 
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
--><div class="section" id="id1">
<h1>调试工具<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>在Doris的使用、开发过程中，经常会遇到需要对Doris进行调试的场景，这里介绍一些常用的调试工具。</p>
<div class="section" id="id2">
<h2>环境准备<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/google/pprof">pprof</a>: 来自gperftools，用于将gperftools所产生的内容转化成便于人可以阅读的格式，比如pdf, svg, text等.</p>
<p><a class="reference external" href="http://www.graphviz.org/">graphviz</a>: 在没有这个库的时候pprof只可以转化为text格式，但这种方式不易查看。那么安装这个库后，pprof可以转化为svg、pdf等格式，对于调用关系则更加清晰明了。</p>
<p><a class="reference external" href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>: linux内核自带性能分析工具。<a class="reference external" href="http://www.brendangregg.com/perf.html">这里</a>有一些perf的使用例子。</p>
<p><a class="reference external" href="https://github.com/brendangregg/FlameGraph">FlameGraph</a>: 可视化工具，用于将perf的输出以火焰图的形式展示出来。</p>
</div>
<div class="section" id="id3">
<h2>内存<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>对于内存的调试一般分为两个方面。一个是内存使用的总量是否合理，内存使用量过大一方面可能是由于系统存在内存泄露，另一方面可能是因为程序内存使用不当。其次就是是否存在内存越界、非法访问的问题，比如程序访问一个非法地址的内存，使用了未初始化内存等。对于内存方面的调试我们一般使用如下几种方式来进行问题追踪。</p>
<div class="section" id="id4">
<h3>查看日志<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>当发现内存使用量过大的时候，我们可以先查看be.out日志，看看是否有大内存申请。由于Doris当前使用的TCMalloc管理内存，那么遇到大内存申请时，都会将申请的堆栈打印到be.out文件中，一般的表现形式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tcmalloc</span><span class="p">:</span> <span class="n">large</span> <span class="n">alloc</span> <span class="mi">1396277248</span> <span class="nb">bytes</span> <span class="o">==</span> <span class="mh">0x3f3488000</span> <span class="o">@</span>  <span class="mh">0x2af6f63</span> <span class="mh">0x2c4095b</span> <span class="mh">0x134d278</span> <span class="mh">0x134bdcb</span> <span class="mh">0x133d105</span> <span class="mh">0x133d1d0</span> <span class="mh">0x19930ed</span>
</pre></div>
</div>
<p>这个表示在Doris BE在这个堆栈上尝试申请<code class="docutils literal notranslate"><span class="pre">1396277248</span> <span class="pre">bytes</span></code>的内存。我们可以通过<code class="docutils literal notranslate"><span class="pre">addr2line</span></code>命令去把堆栈还原成我们能够看懂的信，具体的例子如下所示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ addr2line -e lib/palo_be  0x2af6f63 0x2c4095b 0x134d278 0x134bdcb 0x133d105 0x133d1d0 0x19930ed

/home/ssd0/zc/palo/doris/core/thirdparty/src/gperftools-gperftools-2.7/src/tcmalloc.cc:1335
/home/ssd0/zc/palo/doris/core/thirdparty/src/gperftools-gperftools-2.7/src/tcmalloc.cc:1357
/home/disk0/baidu-doris/baidu/bdg/doris-baidu/core/be/src/exec/hash_table.cpp:267
/home/disk0/baidu-doris/baidu/bdg/doris-baidu/core/be/src/exec/hash_table.hpp:86
/home/disk0/baidu-doris/baidu/bdg/doris-baidu/core/be/src/exec/hash_join_node.cpp:239
/home/disk0/baidu-doris/baidu/bdg/doris-baidu/core/be/src/exec/hash_join_node.cpp:213
thread.cpp:?
</pre></div>
</div>
</div>
<div class="section" id="heap-profile">
<h3>HEAP PROFILE<a class="headerlink" href="#heap-profile" title="Permalink to this headline">¶</a></h3>
<p>有时内存的申请并不是大内存的申请导致，而是通过小内存不断的堆积导致的。那么就没有办法通过查看日志定位到具体的申请信息，那么就需要通过其他方式来获得信息。</p>
<p>这个时候我们可以利用TCMalloc的<a class="reference external" href="https://gperftools.github.io/gperftools/heapprofile.html">HEAPPROFILE</a>的功能。如果设置了HEAPPROFILE功能，那么我们可以获得进程整体的内存申请使用情况。使用方式是在启动Doris BE前设置<code class="docutils literal notranslate"><span class="pre">HEAPPROFILE</span></code>环境变量。比如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">HEAPPROFILE</span><span class="o">=/</span><span class="n">tmp</span><span class="o">/</span><span class="n">doris_be</span><span class="o">.</span><span class="n">hprof</span>
<span class="o">./</span><span class="nb">bin</span><span class="o">/</span><span class="n">start_be</span><span class="o">.</span><span class="n">sh</span> <span class="o">--</span><span class="n">daemon</span>
</pre></div>
</div>
<p>这样，当满足HEAPPROFILE的dump条件时，就会将内存的整体使用情况写到指定路径的文件中。后续我们就可以通过使用<code class="docutils literal notranslate"><span class="pre">pprof</span></code>工具来对输出的内容进行分析。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pprof --text lib/palo_be /tmp/doris_be.hprof.0012.heap | head -30

Using local file lib/palo_be.
Using local file /tmp/doris_be.hprof.0012.heap.
Total: 668.6 MB
   610.6  91.3%  91.3%    610.6  91.3% doris::SystemAllocator::allocate_via_malloc (inline)
    18.1   2.7%  94.0%     18.1   2.7% _objalloc_alloc
     5.6   0.8%  94.9%     63.4   9.5% doris::RowBatch::RowBatch
     5.1   0.8%  95.6%      7.1   1.1% butil::ResourcePool::add_block (inline)
     3.7   0.5%  96.2%      3.7   0.5% butil::iobuf::create_block (inline)
     3.4   0.5%  96.7%      3.4   0.5% butil::FlatMap::init
     3.2   0.5%  97.2%      5.2   0.8% butil::ObjectPool::add_block (inline)
     2.6   0.4%  97.6%      2.6   0.4% __gnu_cxx::new_allocator::allocate (inline)
     2.0   0.3%  97.9%      2.0   0.3% butil::ObjectPool::add_block_group (inline)
     2.0   0.3%  98.2%      2.0   0.3% butil::ResourcePool::add_block_group (inline)
     1.7   0.3%  98.4%      1.7   0.3% doris::SegmentReader::_load_index
</pre></div>
</div>
<p>上述文件各个列的内容：</p>
<ul class="simple">
<li>第一列：函数直接申请的内存大小，单位MB</li>
<li>第四列：函数以及函数所有调用的函数总共内存大小。</li>
<li>第二列、第五列分别是第一列与第四列的的比例值。</li>
<li>第三列是个第二列的累积值。</li>
</ul>
<p>当然也可以生成调用关系图片，更加方便分析。比如下面的命令就能够生成SVG格式的调用关系图。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprof</span> <span class="o">--</span><span class="n">svg</span> <span class="n">lib</span><span class="o">/</span><span class="n">palo_be</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">doris_be</span><span class="o">.</span><span class="n">hprof</span><span class="o">.</span><span class="mf">0012.</span><span class="n">heap</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">svg</span> 
</pre></div>
</div>
<p><strong>注意：开启这个选项是要影响程序的执行性能的，请慎重对线上的实例开启</strong></p>
</div>
<div class="section" id="pprof-remote-server">
<h3>pprof remote server<a class="headerlink" href="#pprof-remote-server" title="Permalink to this headline">¶</a></h3>
<p>HEAPPROFILE虽然能够获得全部的内存使用信息，但是也有比较受限的地方。1. 需要重启BE进行。2. 需要一直开启这个命令，导致对整个进程的性能造成影响。</p>
<p>对Doris BE也可以使用动态开启、关闭heap profile的方式来对进程进行内存申请分析。Doris内部支持了GPerftools的<a class="reference external" href="https://gperftools.github.io/gperftools/pprof_remote_servers.html">远程server调试</a>。那么可以通过<code class="docutils literal notranslate"><span class="pre">pprof</span></code>直接对远程运行的Doris BE进行动态的HEAP PROFILE。比如我们可以通过以下命令来查看Doris的内存的使用增量</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pprof --text --seconds=60 http://be_host:be_webport/pprof/heap 

Total: 1296.4 MB
   484.9  37.4%  37.4%    484.9  37.4% doris::StorageByteBuffer::create
   272.2  21.0%  58.4%    273.3  21.1% doris::RowBlock::init
   157.5  12.1%  70.5%    157.5  12.1% doris::RowBatch::RowBatch
    90.7   7.0%  77.5%     90.7   7.0% doris::SystemAllocator::allocate_via_malloc
    66.6   5.1%  82.7%     66.6   5.1% doris::IntegerColumnReader::init
    47.9   3.7%  86.4%     47.9   3.7% __gnu_cxx::new_allocator::allocate
    20.8   1.6%  88.0%     35.4   2.7% doris::SegmentReader::_load_index
    12.7   1.0%  89.0%     12.7   1.0% doris::DecimalColumnReader::init
    12.7   1.0%  89.9%     12.7   1.0% doris::LargeIntColumnReader::init
    12.7   1.0%  90.9%     12.7   1.0% doris::StringColumnDirectReader::init
    12.3   0.9%  91.9%     12.3   0.9% std::__cxx11::basic_string::_M_mutate
    10.4   0.8%  92.7%     10.4   0.8% doris::VectorizedRowBatch::VectorizedRowBatch
    10.0   0.8%  93.4%     10.0   0.8% doris::PlainTextLineReader::PlainTextLineReader
</pre></div>
</div>
<p>这个命令的输出与HEAP PROFILE的输出及查看方式一样，这里就不再详细说明。这个命令只有在执行的过程中才会开启统计，相比HEAP PROFILE对于进程性能的影响有限。</p>
</div>
<div class="section" id="lsan">
<h3>LSAN<a class="headerlink" href="#lsan" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer">LSAN</a>是一个地址检查工具，GCC已经集成。在我们编译代码的时候开启相应的编译选项，就能够开启这个功能。当程序发生可以确定的内存泄露时，会将泄露堆栈打印。Doris BE已经集成了这个工具，只需要在编译的时候使用如下的命令进行编译就能够生成带有内存泄露检测版本的BE二进制</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BUILD_TYPE</span><span class="o">=</span><span class="n">LSAN</span> <span class="o">./</span><span class="n">build</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>当系统检测到内存泄露的时候，就会在be.out里面输出对应的信息。为了下面的演示，我们故意在代码中插入一段内存泄露代码。我们在<code class="docutils literal notranslate"><span class="pre">StorageEngine</span></code>的<code class="docutils literal notranslate"><span class="pre">open</span></code>函数中插入如下代码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">char</span><span class="o">*</span> <span class="n">leak_buf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">leak_buf</span><span class="p">,</span> <span class="s2">&quot;hello world&quot;</span><span class="p">);</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">leak_buf</span><span class="p">;</span>
</pre></div>
</div>
<p>我们就在be.out中获得了如下的输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=================================================================</span>
<span class="o">==</span><span class="mi">24732</span><span class="o">==</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">LeakSanitizer</span><span class="p">:</span> <span class="n">detected</span> <span class="n">memory</span> <span class="n">leaks</span>

<span class="n">Direct</span> <span class="n">leak</span> <span class="n">of</span> <span class="mi">1024</span> <span class="n">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="mi">1</span> <span class="nb">object</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">allocated</span> <span class="n">from</span><span class="p">:</span>
    <span class="c1">#0 0xd10586 in operator new[](unsigned long) ../../../../gcc-7.3.0/libsanitizer/lsan/lsan_interceptors.cc:164</span>
    <span class="c1">#1 0xe333a2 in doris::StorageEngine::open(doris::EngineOptions const&amp;, doris::StorageEngine**) /home/ssd0/zc/palo/doris/core/be/src/olap/storage_engine.cpp:104</span>
    <span class="c1">#2 0xd3cc96 in main /home/ssd0/zc/palo/doris/core/be/src/service/doris_main.cpp:159</span>
    <span class="c1">#3 0x7f573b5eebd4 in __libc_start_main (/opt/compiler/gcc-4.8.2/lib64/libc.so.6+0x21bd4)</span>

<span class="n">SUMMARY</span><span class="p">:</span> <span class="n">LeakSanitizer</span><span class="p">:</span> <span class="mi">1024</span> <span class="n">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">leaked</span> <span class="ow">in</span> <span class="mi">1</span> <span class="n">allocation</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>从上述的输出中，我们能看到有1024个字节被泄露了，并且打印出来了内存申请时的堆栈信息。</p>
<p><strong>注意：开启这个选项是要影响程序的执行性能的，请慎重对线上的实例开启</strong></p>
<p><strong>注意：如果开启了LSAN开关的话，tcmalloc就会被自动关闭</strong></p>
</div>
<div class="section" id="asan">
<h3>ASAN<a class="headerlink" href="#asan" title="Permalink to this headline">¶</a></h3>
<p>除了内存使用不合理、泄露以外。有的时候也会发生内存访问非法地址等错误。这个时候我们可以借助<a class="reference external" href="https://github.com/google/sanitizers/wiki/AddressSanitizer">ASAN</a>来辅助我们找到问题的原因。与LSAN一样，ASAN也集成在了GCC中。Doris通过如下的方式进行编译就能够开启这个功能</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BUILD_TYPE</span><span class="o">=</span><span class="n">ASAN</span> <span class="o">./</span><span class="n">build</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>执行编译生成的二进制文件，当检测工具发现有异常访问时，就会立即退出，并将非法访问的堆栈输出在be.out中。对于ASAN的输出与LSAN是一样的分析方法。这里我们也主动注入一个地址访问错误，来展示下具体的内容输出。我们仍然在<code class="docutils literal notranslate"><span class="pre">StorageEngine</span></code>的<code class="docutils literal notranslate"><span class="pre">open</span></code>函数中注入一段非法内存访问，具体的错误代码如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">char</span><span class="o">*</span> <span class="n">invalid_buf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1025</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">invalid_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">invalid_buf</span><span class="p">;</span>
</pre></div>
</div>
<p>然后我们就会在be.out中获得如下的输出</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=================================================================</span>
<span class="o">==</span><span class="mi">23284</span><span class="o">==</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">AddressSanitizer</span><span class="p">:</span> <span class="n">heap</span><span class="o">-</span><span class="n">buffer</span><span class="o">-</span><span class="n">overflow</span> <span class="n">on</span> <span class="n">address</span> <span class="mh">0x61900008bf80</span> <span class="n">at</span> <span class="n">pc</span> <span class="mh">0x00000129f56a</span> <span class="n">bp</span> <span class="mh">0x7fff546eed90</span> <span class="n">sp</span> <span class="mh">0x7fff546eed88</span>
<span class="n">WRITE</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x61900008bf80</span> <span class="n">thread</span> <span class="n">T0</span>
    <span class="c1">#0 0x129f569 in doris::StorageEngine::open(doris::EngineOptions const&amp;, doris::StorageEngine**) /home/ssd0/zc/palo/doris/core/be/src/olap/storage_engine.cpp:106</span>
    <span class="c1">#1 0xe2c1e3 in main /home/ssd0/zc/palo/doris/core/be/src/service/doris_main.cpp:159</span>
    <span class="c1">#2 0x7fa5580fbbd4 in __libc_start_main (/opt/compiler/gcc-4.8.2/lib64/libc.so.6+0x21bd4)</span>
    <span class="c1">#3 0xd30794  (/home/ssd0/zc/palo/doris/core/output3/be/lib/palo_be+0xd30794)</span>

<span class="mh">0x61900008bf80</span> <span class="ow">is</span> <span class="n">located</span> <span class="mi">0</span> <span class="nb">bytes</span> <span class="n">to</span> <span class="n">the</span> <span class="n">right</span> <span class="n">of</span> <span class="mi">1024</span><span class="o">-</span><span class="n">byte</span> <span class="n">region</span> <span class="p">[</span><span class="mh">0x61900008bb80</span><span class="p">,</span><span class="mh">0x61900008bf80</span><span class="p">)</span>
<span class="n">allocated</span> <span class="n">by</span> <span class="n">thread</span> <span class="n">T0</span> <span class="n">here</span><span class="p">:</span>
    <span class="c1">#0 0xdeb040 in operator new[](unsigned long) ../../../../gcc-7.3.0/libsanitizer/asan/asan_new_delete.cc:82</span>
    <span class="c1">#1 0x129f50d in doris::StorageEngine::open(doris::EngineOptions const&amp;, doris::StorageEngine**) /home/ssd0/zc/palo/doris/core/be/src/olap/storage_engine.cpp:104</span>
    <span class="c1">#2 0xe2c1e3 in main /home/ssd0/zc/palo/doris/core/be/src/service/doris_main.cpp:159</span>
    <span class="c1">#3 0x7fa5580fbbd4 in __libc_start_main (/opt/compiler/gcc-4.8.2/lib64/libc.so.6+0x21bd4)</span>

<span class="n">SUMMARY</span><span class="p">:</span> <span class="n">AddressSanitizer</span><span class="p">:</span> <span class="n">heap</span><span class="o">-</span><span class="n">buffer</span><span class="o">-</span><span class="n">overflow</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ssd0</span><span class="o">/</span><span class="n">zc</span><span class="o">/</span><span class="n">palo</span><span class="o">/</span><span class="n">doris</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">be</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">olap</span><span class="o">/</span><span class="n">storage_engine</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">106</span> <span class="ow">in</span> <span class="n">doris</span><span class="p">::</span><span class="n">StorageEngine</span><span class="p">::</span><span class="nb">open</span><span class="p">(</span><span class="n">doris</span><span class="p">::</span><span class="n">EngineOptions</span> <span class="n">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">doris</span><span class="p">::</span><span class="n">StorageEngine</span><span class="o">**</span><span class="p">)</span>
</pre></div>
</div>
<p>从这段信息中该可以看到在<code class="docutils literal notranslate"><span class="pre">0x61900008bf80</span></code>这个地址我们尝试去写一个字节，但是这个地址是非法的。我们也可以看到 <code class="docutils literal notranslate"><span class="pre">[0x61900008bb80,0x61900008bf80)</span></code>这个地址的申请堆栈。</p>
<p><strong>注意：开启这个选项是要影响程序的执行性能的，请慎重对线上的实例开启</strong></p>
<p><strong>注意：如果开启了ASAN开关的话，tcmalloc就会被自动关闭</strong></p>
<p>另外，如果be.out中输出了堆栈信息，但是并没有函数符号，那么这个时候需要我们手动的处理下才能获得可读的堆栈信息。具体的处理方法需要借助一个脚本来解析ASAN的输出。这个时候我们需要使用<a class="reference external" href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/asan/scripts/asan_symbolize.py">asan_symbolize</a>来帮忙解析下。具体的使用方式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="n">be</span><span class="o">.</span><span class="n">out</span> <span class="o">|</span> <span class="n">python</span> <span class="n">asan_symbolize</span><span class="o">.</span><span class="n">py</span> <span class="o">|</span> <span class="n">c</span><span class="o">++</span><span class="n">filt</span>
</pre></div>
</div>
<p>通过上述的命令，我们就能够获得可读的堆栈信息了。</p>
</div>
</div>
<div class="section" id="cpu">
<h2>CPU<a class="headerlink" href="#cpu" title="Permalink to this headline">¶</a></h2>
<p>当系统的CPU Idle很低的时候，说明系统的CPU已经成为了主要瓶颈，这个时候就需要分析一下当前的CPU使用情况。对于Doris的BE可以有如下两种方式来分析Doris的CPU瓶颈。</p>
<div class="section" id="pprof">
<h3>pprof<a class="headerlink" href="#pprof" title="Permalink to this headline">¶</a></h3>
<p>由于Doris内部已经集成了并兼容了GPerf的REST接口，那么用户可以通过<code class="docutils literal notranslate"><span class="pre">pprof</span></code>工具来分析远程的Doris BE。具体的使用方式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pprof</span> <span class="o">--</span><span class="n">svg</span> <span class="o">--</span><span class="n">seconds</span><span class="o">=</span><span class="mi">60</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">be_host</span><span class="p">:</span><span class="n">be_webport</span><span class="o">/</span><span class="n">pprof</span><span class="o">/</span><span class="n">profile</span> <span class="o">&gt;</span> <span class="n">be</span><span class="o">.</span><span class="n">svg</span> 
</pre></div>
</div>
<p>这样就能够生成一张BE执行的CPU消耗图。</p>
<p><img alt="../../../_images/cpu-pprof-demo.png" src="../../../_images/cpu-pprof-demo.png" />CPU Pprof</p>
</div>
<div class="section" id="perf-flamegragh">
<h3>perf + flamegragh<a class="headerlink" href="#perf-flamegragh" title="Permalink to this headline">¶</a></h3>
<p>这个是相当通用的一种CPU分析方式，相比于<code class="docutils literal notranslate"><span class="pre">pprof</span></code>，这中方式必须要求能够登陆到分析对象的物理机上。但是相比于pprof只能定时采点，perf是能够通过不同的事件来完成堆栈信息采集的。具体的的使用方式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perf</span> <span class="n">record</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">p</span> <span class="n">be_pid</span> <span class="o">--</span> <span class="n">sleep</span> <span class="mi">60</span>
</pre></div>
</div>
<p>这条命令会统计60秒钟BE的CPU运行情况，并且生成perf.data。对于perf.data的分析，可以通过perf的命令来进行分析</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perf</span> <span class="n">report</span>
</pre></div>
</div>
<p>分析得到如下的图片</p>
<p><img alt="../../../_images/perf-report-demo.png" src="../../../_images/perf-report-demo.png" />Perf Report</p>
<p>来对生成的内容进行分析。当然也可以使用flamegragh完成可视化展示。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perf</span> <span class="n">script</span> <span class="o">|</span> <span class="o">./</span><span class="n">FlameGraph</span><span class="o">/</span><span class="n">stackcollapse</span><span class="o">-</span><span class="n">perf</span><span class="o">.</span><span class="n">pl</span> <span class="o">|</span> <span class="o">./</span><span class="n">FlameGraph</span><span class="o">/</span><span class="n">flamegraph</span><span class="o">.</span><span class="n">pl</span> <span class="o">&gt;</span> <span class="n">be</span><span class="o">.</span><span class="n">svg</span>
</pre></div>
</div>
<p>这样也会生成一张当时运行的CPU消耗图。</p>
<p><img alt="../../../_images/cpu-flame-demo.svg" src="../../../_images/cpu-flame-demo.svg" />CPU Flame</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../community/index.html" class="btn btn-neutral float-right" title="Apache 社区" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="开发者手册" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Apache Doris(Incubating)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
<div role="contentinfo">
    <p></p>
    <p>

        Apache Doris(incubating) is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.

    </p>
</div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>